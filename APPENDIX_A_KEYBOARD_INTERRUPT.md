# 附录A：键盘中断处理代码分析

以下代码演示了如何直接处理键盘硬件中断（INT 09h），展示了硬件中断与软件中断的实际应用。

## 代码概述

这段代码实现了一个键盘输入处理演示程序，它：
1. **直接挂钩硬件中断**（INT 09h，键盘硬件中断）
2. **在中断处理程序中读取按键**（直接从键盘端口读取扫描码）
3. **显示按键消息**（当用户按下按键时显示 "'x' was pressed!"）
4. **调用原始 BIOS 处理程序**（保持系统兼容性）

## 关键代码分析

### 1. 中断向量表（IVT）的修改

```asm
setup_keyboard_handler:
    cli                 ; 关中断，防止在设置过程中被中断
    
    ; 保存原始中断向量
    mov ax, 0
    mov es, ax          ; es = 0（中断向量表在段 0）
    mov bx, 0x09 * 4    ; INT 09h 向量地址 = 0x0024
    
    ; 读取原始向量
    mov ax, [es:bx]     ; 读取偏移地址（低 2 字节）
    mov [old_int09_offset], ax
    mov ax, [es:bx+2]   ; 读取段地址（高 2 字节）
    mov [old_int09_segment], ax
    
    ; 设置新的中断向量
    mov word [es:bx], keyboard_handler
    mov [es:bx+2], cs   ; 设置段地址为当前代码段
    
    sti                 ; 开中断，允许中断处理
```

**分析：**

- **IVT 位置**：`0x0000:0000`，INT 09h 的条目在 `0x0000:0024`（`0x09 × 4 = 0x24`）
- **保存原始向量**：必须保存，以便后续调用原始 BIOS 处理程序
- **设置新向量**：将 IVT[0x09] 指向自定义的 `keyboard_handler`
- **关中断（CLI）**：修改 IVT 时必须关中断，防止在修改过程中发生中断导致系统崩溃

**与之前讨论的关系：**

- 这段代码直接修改了 BIOS 在 `ivt_init()` 中设置的 IVT 条目
- 原始 IVT[0x09] 指向 `entry_hwpic1`（主 PIC 硬件中断处理程序）
- 现在被替换为自定义的 `keyboard_handler`

### 2. 硬件中断处理程序

```asm
keyboard_handler:
    ; 保存所有寄存器
    push ax
    push bx
    push cx
    push dx
    push si
    push ds
    push es
    
    ; 从键盘端口读取扫描码
    in al, 0x60         ; 0x60 是键盘数据端口
    
    ; 检查是否是按键释放
    test al, 0x80      ; 最高位：0=按下，1=释放
    jnz .key_release
    
    ; 处理按键按下
    mov [last_scancode], al
    call scancode_to_ascii
    
    ; 显示消息
    mov ah, 0x0E
    mov al, 0x27       ; 单引号
    int 0x10
    mov al, [last_ascii]
    int 0x10
    mov al, 0x27
    int 0x10
    mov si, msg_was_pressed
    call print_string_interrupt
    
    ; 发送 EOI 到 PIC
.skip_display:
    mov al, 0x20
    out 0x20, al       ; 主 PIC 命令端口
    
    ; 调用原始 BIOS 处理程序
    pushf
    call far [old_int09_offset]
    
.key_release:
    mov al, 0x20
    out 0x20, al
    pushf
    call far [old_int09_offset]
    
.done:
    pop es
    pop ds
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    iret               ; 中断返回
```

**分析：**

1. **寄存器保存**：
   - 中断处理程序必须保存所有使用的寄存器
   - 使用 `push` 保存，`pop` 恢复

2. **读取键盘数据**：
   - `in al, 0x60`：从键盘数据端口（0x60）读取扫描码
   - 这与 SeaBIOS 的 `handle_09()` 中的 `inb(PORT_PS2_DATA)` 相同

3. **扫描码处理**：
   - 扫描码最高位：0 = 按下，1 = 释放
   - 只处理按键按下事件，忽略释放事件

4. **EOI（End of Interrupt）**：
   - `mov al, 0x20; out 0x20, al`：发送 EOI 到主 PIC
   - 这与 SeaBIOS 的 `pic_eoi1()` 相同
   - **必须发送 EOI**，否则 PIC 不会处理下一个中断

5. **调用原始处理程序**：
   - `call far [old_int09_offset]`：调用原始 BIOS 键盘处理程序
   - 这确保了 BIOS 的键盘缓冲区（BDA）仍然被更新
   - 保持了系统兼容性

6. **中断返回**：
   - `iret`：恢复 IP、CS、FLAGS，继续执行被中断的程序

### 3. 主循环：等待中断

```asm
main_loop:
    hlt                 ; 暂停 CPU，等待中断（节省电力）
    jmp main_loop       ; 如果从 hlt 唤醒，继续循环
```

**分析：**

- **HLT 指令**：暂停 CPU，直到发生中断
- **中断唤醒**：当键盘中断发生时，CPU 被唤醒，执行 `keyboard_handler`
- **异步处理**：不需要轮询键盘，中断会自动触发处理程序

## 与之前讨论的关系

### 1. 硬件中断 vs 软件中断

| 特性 | 本代码（直接处理硬件中断） | INT 16h（软件中断） |
|------|------------------------|-------------------|
| **中断向量** | INT 09h（硬件中断，IRQ1） | INT 16h（软件中断） |
| **触发方式** | 硬件自动触发（按键时） | 用户程序主动调用 |
| **数据来源** | 直接从键盘端口读取（0x60） | 从键盘缓冲区读取 |
| **处理时机** | 异步（按键时立即触发） | 同步（用户程序需要时） |
| **使用场景** | 实时响应、自定义处理 | 标准键盘输入 API |

### 2. 中断处理流程对比

**本代码的处理流程：**

```
用户按下键盘
    ↓
IRQ1 硬件中断 → 向量 0x09
    ↓
keyboard_handler（自定义处理程序）
    ├─ 读取扫描码（in al, 0x60）
    ├─ 转换为 ASCII
    ├─ 显示消息
    ├─ 发送 EOI
    └─ 调用原始 BIOS 处理程序（更新缓冲区）
    ↓
返回被中断的程序
```

**标准 INT 16h 的处理流程：**

```
用户按下键盘
    ↓
IRQ1 硬件中断 → 向量 0x09
    ↓
handle_09()（BIOS 硬件中断处理程序）
    ├─ 读取扫描码
    ├─ process_key() → enqueue_key()
    └─ 数据存入缓冲区
    ↓
用户程序调用 INT 16h
    ↓
handle_16()（BIOS 软件中断处理程序）
    ├─ dequeue_key()
    └─ 从缓冲区读取数据
```

### 3. 关键设计模式

1. **中断向量替换（Hooking）**：
   - 保存原始中断向量
   - 设置新的中断向量指向自定义处理程序
   - 在自定义处理程序中调用原始处理程序（链式调用）

2. **中断处理程序规范**：
   - 保存所有寄存器
   - 快速执行（中断处理程序应该尽可能快）
   - 发送 EOI 到 PIC
   - 使用 `iret` 返回

3. **硬件端口访问**：
   - `in al, 0x60`：读取键盘数据端口
   - `out 0x20, al`：写入 PIC 命令端口
   - 直接访问硬件，不通过 BIOS 服务

## 代码的优缺点

**优点：**

1. **实时响应**：直接处理硬件中断，响应速度快
2. **完全控制**：可以自定义键盘处理逻辑
3. **系统兼容**：调用原始 BIOS 处理程序，保持兼容性

**缺点：**

1. **复杂性**：需要处理硬件细节（扫描码、EOI 等）
2. **兼容性风险**：直接修改 IVT 可能影响其他程序
3. **代码大小**：中断处理程序增加了代码大小（在 512 字节限制下很重要）

## 实际应用场景

1. **引导程序**：在引导过程中需要实时响应键盘输入
2. **调试工具**：需要捕获所有键盘事件
3. **安全程序**：需要拦截键盘输入（如密码输入保护）

## 与 SeaBIOS 实现的对比

| 特性 | 本代码 | SeaBIOS |
|------|--------|---------|
| **中断处理** | 直接处理硬件中断 | 硬件中断 + 软件中断（INT 16h） |
| **数据存储** | 不存储（只显示） | 存储到键盘缓冲区（BDA） |
| **API 提供** | 无（直接处理） | 提供 INT 16h API |
| **使用场景** | 演示、特殊用途 | 标准 BIOS 服务 |

## 总结

这段代码展示了：

1. **硬件中断的直接处理**：不通过 BIOS 软件中断（INT 16h），直接处理硬件中断（INT 09h）
2. **中断向量表的修改**：如何保存和替换 IVT 条目
3. **中断处理程序规范**：寄存器保存、EOI 发送、原始处理程序调用
4. **硬件端口访问**：直接读取键盘数据端口

**关键理解：**

- **硬件中断是自动的**：无论是否调用 INT 16h，硬件中断都会触发
- **可以直接处理硬件中断**：不需要通过 BIOS 软件中断服务
- **必须保持系统兼容性**：调用原始 BIOS 处理程序，确保系统正常工作
- **中断处理程序必须快速**：应该尽快完成处理并返回

这段代码是理解硬件中断和软件中断关系的很好示例，展示了如何在实际应用中直接处理硬件中断。

## 重要澄清：INT 09h 键盘硬件中断

**Demo 程序处理的是 INT 09h（键盘硬件中断）**

**Demo 程序的处理对象：**

```asm
mov bx, 0x09 * 4    ; INT 09h 向量地址 = 0x0024
```

- Demo 程序挂钩的是 **INT 09h**（向量 0x09）
- 这是**键盘硬件中断**（IRQ1）
- 当用户按下键盘时，硬件自动触发 IRQ1 → PIC 路由到向量 0x09 → 调用 `keyboard_handler`

## 硬件中断编号（IRQ）vs 中断向量号（IVT/IDT 索引）

**重要概念区分：**

### 1. 硬件中断编号（IRQ - Interrupt Request）

**IRQ 是硬件层面的编号，由硬件设备决定：**

| IRQ | 设备 | 说明 |
|-----|------|------|
| **IRQ0** | 系统定时器 | 硬件固定：定时器芯片 |
| **IRQ1** | 键盘 | 硬件固定：键盘控制器 |
| **IRQ2** | 从 PIC 级联 | 硬件固定：PIC 级联 |
| **IRQ3** | 串口 COM2 | 硬件固定：串口控制器 |
| **IRQ4** | 串口 COM1 | 硬件固定：串口控制器 |
| **IRQ6** | 软盘控制器 | 硬件固定：软盘控制器 |
| **IRQ14** | 主 IDE 控制器 | 硬件固定：IDE 控制器 |
| **IRQ15** | 从 IDE 控制器 | 硬件固定：IDE 控制器 |

**IRQ 的特点：**

1. **硬件固定**：IRQ 编号由硬件设备决定，不能随意更改
   - 键盘总是使用 IRQ1
   - 定时器总是使用 IRQ0
   - 这是**硬件设计决定的**

2. **PIC 管理**：8259A PIC 管理 16 个 IRQ（IRQ0-15）
   - 主 PIC 管理 IRQ0-7
   - 从 PIC 管理 IRQ8-15

3. **可配置性**：虽然 IRQ 编号固定，但可以：
   - **禁用/启用**某个 IRQ（通过 PIC 的 IMR）
   - **重映射**到不同的中断向量（通过 PIC 的 ICW2）

### 2. 中断向量号（IVT/IDT 索引）

**中断向量号是 CPU 层面的编号，用于查找中断处理程序：**

**重要：x86 架构总共有 256 个中断向量号（0-255）**

- **IVT（实模式）**：256 个条目（0-255），每个条目 4 字节
- **IDT（保护模式/长模式）**：256 个条目（0-255），每个条目 8 字节（32位）或 16 字节（64位）

| 向量号范围 | 用途 | 说明 | 数量 |
|-----------|------|------|------|
| **0-31** | CPU 异常 | CPU 硬件固定（如向量 0=除零，向量 14=页错误） | 32 个 |
| **0x08-0x0F** | 硬件中断（IRQ0-7） | **可配置**：由 PIC 的 ICW2 决定 | 8 个 |
| **0x70-0x77** | 硬件中断（IRQ8-15） | **可配置**：由 PIC 的 ICW2 决定 | 8 个 |
| **0x10, 0x16** 等 | 软件中断 | **可配置**：由 BIOS/操作系统决定 | 可变 |
| **其他（0x20-0x6F, 0x78-0xFF）** | 保留/未使用 | 可用于软件中断或其他用途 | 可变 |

**总计：256 个中断向量号（0x00-0xFF）**

**中断向量号的特点：**

1. **部分固定，部分可配置**：
   - **CPU 异常向量（0-31）**：CPU 硬件固定，不能更改
   - **硬件中断向量（0x08-0x0F, 0x70-0x77）**：**可配置**，由 PIC 的 ICW2 决定
   - **软件中断向量（0x10+）**：**可配置**，由 BIOS/操作系统决定

2. **PIC 重映射**：
   ```c
   // BIOS 配置：IRQ0-7 → 向量 0x08-0x0F
   // 内核配置：IRQ0-7 → 向量 0x20-0x27
   ```
   - IRQ 编号不变（IRQ1 仍然是 IRQ1）
   - 但可以映射到不同的向量号（0x09 或 0x21）

### 3. IRQ 到中断向量号的映射

**映射关系（BIOS 默认配置）：**

```
硬件设备 → IRQ → PIC → 中断向量号 → IVT/IDT → 处理程序
```

**示例：键盘中断**

**BIOS 默认配置：**
```
键盘硬件 → IRQ1 → 主 PIC → 向量 0x09 → IVT[0x09] → handle_09()
```

**内核配置（重新编程 PIC 后）：**
```
键盘硬件 → IRQ1 → 主 PIC → 向量 0x21 → IDT[0x21] → 内核键盘处理程序
```

**SeaBIOS 如何完成 IRQ1 → 向量 0x09 的映射：**

**源代码位置：`seabios/src/hw/pic.h:31-32`**

```c
// 定义硬件中断向量的基址
#define BIOS_HWIRQ0_VECTOR 0x08  // 主 PIC：IRQ0-7 的基址向量
#define BIOS_HWIRQ8_VECTOR 0x70   // 从 PIC：IRQ8-15 的基址向量
```

**源代码位置：`seabios/src/hw/pic.c:62-66`**

```c
// PIC 初始化函数
void pic_setup(void)
{
    dprintf(3, "init pic\n");
    // 调用 pic_reset() 配置 PIC
    // 参数：irq0 = 0x08（IRQ0-7 的基址向量）
    //       irq8 = 0x70（IRQ8-15 的基址向量）
    pic_reset(BIOS_HWIRQ0_VECTOR, BIOS_HWIRQ8_VECTOR);
}
```

**源代码位置：`seabios/src/hw/pic.c:41-59`**

```c
// PIC 重置和配置函数
void pic_reset(u8 irq0, u8 irq8)
{
    if (!CONFIG_HARDWARE_IRQ)
        return;
    
    // 步骤 1: 发送 ICW1（初始化命令字 1）
    // 0x11 = 边沿触发、级联模式、需要 ICW4
    outb(0x11, PORT_PIC1_CMD);  // 主 PIC 命令端口 0x20
    outb(0x11, PORT_PIC2_CMD);  // 从 PIC 命令端口 0xA0
    
    // 步骤 2: 发送 ICW2（初始化命令字 2）- 关键步骤！
    // ICW2 配置中断向量基址
    // irq0 = 0x08，这是中断向量基址（不是 IRQ 编号！）
    // PIC 会自动计算：实际向量 = 基址 + IRQ 编号
    // 因此：
    //   IRQ0 → 向量 0x08（0x08 + 0）
    //   IRQ1 → 向量 0x09（0x08 + 1）← 键盘中断
    //   IRQ2 → 向量 0x0A（0x08 + 2）
    //   ...
    //   IRQ7 → 向量 0x0F（0x08 + 7）
    outb(irq0, PORT_PIC1_DATA);  // 主 PIC 数据端口 0x21，写入 0x08（向量基址）
    outb(irq8, PORT_PIC2_DATA);  // 从 PIC 数据端口 0xA1，写入 0x70（向量基址）
    
    // 步骤 3: 发送 ICW3（初始化命令字 3）- 级联配置
    outb(0x04, PORT_PIC1_DATA);  // 主 PIC：从 PIC 连接到 IR2
    outb(0x02, PORT_PIC2_DATA);  // 从 PIC：连接到主 PIC 的 IR2
    
    // 步骤 4: 发送 ICW4（初始化命令字 4）- 工作模式
    outb(0x01, PORT_PIC1_DATA);  // 8086 模式
    outb(0x01, PORT_PIC2_DATA);  // 8086 模式
    
    // 步骤 5: 屏蔽所有中断（除了级联的从 PIC）
    pic_irqmask_write(PIC_IRQMASK_DEFAULT);
}
```

**完整映射流程：**

```
1. pic_setup() 被调用
   ↓
2. 调用 pic_reset(0x08, 0x70)
   ↓
3. 发送 ICW1（初始化命令）
   ↓
4. 发送 ICW2（配置向量基址）
   ├─ 主 PIC：outb(0x08, 0x21)  ← 关键！
   │   └─ IRQ0 → 向量 0x08
   │   └─ IRQ1 → 向量 0x09  ← 键盘
   │   └─ IRQ2 → 向量 0x0A
   │   └─ ...
   └─ 从 PIC：outb(0x70, 0xA1)
       └─ IRQ8 → 向量 0x70
       └─ ...
   ↓
5. 发送 ICW3（级联配置）
   ↓
6. 发送 ICW4（工作模式）
   ↓
7. 配置完成：IRQ1 → 向量 0x09
```

**对比：内核如何重新映射到 0x21**

```c
// linux/arch/x86/kernel/i8259.c:init_8259A()
// 内核重新编程 PIC，将 IRQ0-7 映射到 0x20-0x27
outb_pic(ISA_IRQ_VECTOR(0), PIC_MASTER_IMR);
// ISA_IRQ_VECTOR(0) = 0x20
// 因此：IRQ1（键盘）→ 向量 0x21（0x20 + 1）
```

**关键点：**

1. **IRQ 编号是硬件固定的**：
   - 键盘总是 IRQ1（硬件决定，不能更改）
   - 定时器总是 IRQ0（硬件决定，不能更改）

2. **中断向量号是可配置的**：
   - **BIOS 默认**：IRQ1 → 向量 0x09
   - **内核配置**：IRQ1 → 向量 0x21
   - **可以配置为其他值**：通过 PIC 的 ICW2 可以配置 IRQ1 映射到任意向量号（只要不与 CPU 异常向量冲突）

3. **映射关系由 PIC 的 ICW2 决定**：
   - ICW2 配置 PIC 将 IRQ 映射到哪个向量号
   - 不同的系统（BIOS/内核）可以使用不同的映射
   - **0x09 不是必须的**，只是 BIOS 的默认配置

**回答：键盘的硬件中断编号必须是 0x09 吗？**

- ❌ **不是必须的**
- ✅ **IRQ1 是硬件固定的**（键盘总是使用 IRQ1）
- ⚠️ **但中断向量号 0x09 是可配置的**（可以通过 PIC 的 ICW2 配置为其他值）
- 📌 **BIOS 默认配置**：IRQ1 → 向量 0x09（这是 BIOS 的选择，不是硬件要求）
- 📌 **内核配置**：IRQ1 → 向量 0x21（内核重新编程 PIC 后）
- 📌 **理论上可以配置为**：IRQ1 → 向量 0x20-0xFF 中的任意值（只要不与 CPU 异常向量 0-31 冲突）

## 总结对比

| 概念 | 固定性 | 说明 | 示例 |
|------|--------|------|------|
| **IRQ 编号** | ✅ **硬件固定** | 由硬件设备决定 | 键盘 = IRQ1（固定） |
| **中断向量号** | ⚠️ **部分固定，部分可配置** | CPU 异常固定，硬件中断可配置 | IRQ1 → 向量 0x09（BIOS）或 0x21（内核） |
| **IVT/IDT 条目** | ❌ **完全可配置** | 由 BIOS/操作系统设置 | IVT[0x09] = handle_09() |

**回答用户的问题：**

**"硬件中断编号是 CPU 定死的吗？"**

- ✅ **IRQ 编号是硬件固定的**（键盘 = IRQ1，定时器 = IRQ0）
- ⚠️ **但中断向量号是可配置的**（IRQ1 可以映射到 0x09 或 0x21）
- ⚠️ **CPU 异常向量（0-31）是 CPU 固定的**，但硬件中断向量（0x08+）是可配置的

---

**注意**：关于 PIC 端口地址、地址解码电路等更详细的内容，请参考 [中断处理详解](INTERRUPT_HANDLING.md) 文档。

