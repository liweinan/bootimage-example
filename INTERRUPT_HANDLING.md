# 中断处理详解

本文档合并了所有中断相关的内容，包括 BIOS IVT 初始化、硬件中断与软件中断的对比、UEFI 中断处理机制等。

## 目录

1. [BIOS 中断向量表（IVT）初始化](#1-bios-中断向量表ivt初始化)
2. [硬件中断编号（IRQ）vs 中断向量号](#2-硬件中断编号irq-vs-中断向量号)
3. [BIOS IVT 与 Kernel IDT 的软件中断服务程序对比](#3-bios-ivt-与-kernel-idt-的软件中断服务程序对比)
4. [UEFI 中断处理机制](#4-uefi-中断处理机制)
5. [PIC 端口地址与地址解码](#5-pic-端口地址与地址解码)

---

## 1. BIOS 中断向量表（IVT）初始化

**详细内容请参考：** [boot_flow.md - Section 3.3](boot_flow.md#33-中断向量表ivt初始化)

### 1.1 调用时机

`ivt_init()` 在 SeaBIOS POST 初始化流程中被调用，具体调用链如下：

```
CPU 复位 → 0xFFFF0（BIOS 入口点）
    ↓
handle_post()（POST 入口函数）
    ↓
dopost()（POST 处理函数）
    ↓
reloc_preinit(maininit, NULL)（代码重定位后调用主初始化）
    ↓
maininit()（主初始化函数）
    ↓
interface_init()（接口初始化函数，第 200 行调用）
    ↓
ivt_init()（中断向量表初始化，第 113 行调用）← 这里！
```

**调用位置：** `seabios/src/post.c:113`（在 `interface_init()` 函数中）

### 1.2 初始化步骤

`ivt_init()` 为所有 256 个中断向量都设置了条目，采用"先全部初始化，再覆盖特定向量"的策略：

1. **步骤 1**：将所有 256 个中断向量初始化为默认处理程序 `entry_iret_official`
2. **步骤 2**：预先为 8259A PIC 的硬件中断向量设置处理程序（0x08-0x0F, 0x70-0x77）
3. **步骤 3**：初始化软件中断处理程序（BIOS 服务：INT 10h, 13h, 15h, 16h, 19h 等）
4. **步骤 4-5**：设置保留向量为空（0x60-0x66, 0x79）

**关键点：**
- IVT 位于物理内存 `0x0000:0000`，每个向量占 4 字节（段:偏移）
- 所有 256 个向量都有条目，确保即使发生未预期的中断，CPU 也能安全返回
- PIC 初始化之前就设置好硬件中断处理程序，确保后续 PIC 初始化时如果发生中断，IVT 中已有有效处理程序

**详细代码和说明请参考：** [boot_flow.md - Section 3.3](boot_flow.md#33-中断向量表ivt初始化)

---

## 2. 硬件中断编号（IRQ）vs 中断向量号

**详细内容请参考：** [APPENDIX_A_KEYBOARD_INTERRUPT.md - 硬件中断编号（IRQ）vs 中断向量号](APPENDIX_A_KEYBOARD_INTERRUPT.md#硬件中断编号irq-vs-中断向量号ivtidt-索引)

### 2.1 硬件中断编号（IRQ - Interrupt Request）

**IRQ 是硬件层面的编号，由硬件设备决定：**

| IRQ | 设备 | 说明 |
|-----|------|------|
| **IRQ0** | 系统定时器 | 硬件固定：定时器芯片 |
| **IRQ1** | 键盘 | 硬件固定：键盘控制器 |
| **IRQ2** | 从 PIC 级联 | 硬件固定：PIC 级联 |
| **IRQ3** | 串口 COM2 | 硬件固定：串口控制器 |
| **IRQ4** | 串口 COM1 | 硬件固定：串口控制器 |
| **IRQ6** | 软盘控制器 | 硬件固定：软盘控制器 |
| **IRQ14** | 主 IDE 控制器 | 硬件固定：IDE 控制器 |
| **IRQ15** | 从 IDE 控制器 | 硬件固定：IDE 控制器 |

**IRQ 的特点：**
- **硬件固定**：IRQ 编号由硬件设备决定，不能随意更改
- **PIC 管理**：8259A PIC 管理 16 个 IRQ（IRQ0-15）
- **可配置性**：虽然 IRQ 编号固定，但可以禁用/启用或重映射到不同的中断向量

### 2.2 中断向量号（IVT/IDT 索引）

**中断向量号是 CPU 层面的编号，用于查找中断处理程序：**

**重要：x86 架构总共有 256 个中断向量号（0-255）**

| 向量号范围 | 用途 | 说明 | 数量 |
|-----------|------|------|------|
| **0-31** | CPU 异常 | CPU 硬件固定（如向量 0=除零，向量 14=页错误） | 32 个 |
| **0x08-0x0F** | 硬件中断（IRQ0-7） | **可配置**：由 PIC 的 ICW2 决定 | 8 个 |
| **0x70-0x77** | 硬件中断（IRQ8-15） | **可配置**：由 PIC 的 ICW2 决定 | 8 个 |
| **0x10, 0x16** 等 | 软件中断 | **可配置**：由 BIOS/操作系统决定 | 可变 |
| **其他（0x20-0x6F, 0x78-0xFF）** | 保留/未使用 | 可用于软件中断或其他用途 | 可变 |

**中断向量号的特点：**
- **部分固定，部分可配置**：
  - CPU 异常向量（0-31）：CPU 硬件固定，不能更改
  - 硬件中断向量（0x08-0x0F, 0x70-0x77）：**可配置**，由 PIC 的 ICW2 决定
  - 软件中断向量（0x10+）：**可配置**，由 BIOS/操作系统决定

### 2.3 IRQ 到中断向量号的映射

**映射关系（BIOS 默认配置）：**

```
硬件设备 → IRQ → PIC → 中断向量号 → IVT/IDT → 处理程序
```

**示例：键盘中断**

- **BIOS 默认配置**：键盘硬件 → IRQ1 → 主 PIC → 向量 0x09 → IVT[0x09] → handle_09()
- **内核配置（重新编程 PIC 后）**：键盘硬件 → IRQ1 → 主 PIC → 向量 0x21 → IDT[0x21] → 内核键盘处理程序

**SeaBIOS 如何完成 IRQ1 → 向量 0x09 的映射：**

通过 PIC 的 ICW2（初始化命令字 2）配置中断向量基址：

```c
// seabios/src/hw/pic.c:pic_reset()
outb(irq0, PORT_PIC1_DATA);  // irq0 = 0x08（主 PIC 数据端口 0x21）
// PIC 会自动计算：实际向量 = 基址 + IRQ 编号
// 因此：IRQ1 → 向量 0x09（0x08 + 1）← 键盘中断
```

**关键点：**
- **IRQ 编号是硬件固定的**：键盘总是 IRQ1（硬件决定，不能更改）
- **中断向量号是可配置的**：IRQ1 可以映射到 0x09（BIOS）或 0x21（内核）
- **映射关系由 PIC 的 ICW2 决定**：不同的系统（BIOS/内核）可以使用不同的映射

**详细说明请参考：** [APPENDIX_A_KEYBOARD_INTERRUPT.md](APPENDIX_A_KEYBOARD_INTERRUPT.md#硬件中断编号irq-vs-中断向量号ivtidt-索引)

---

## 3. BIOS IVT 与 Kernel IDT 的软件中断服务程序对比

**详细内容请参考：** [boot_flow.md - Section 6.5](boot_flow.md#65-bios-ivt-与-kernel-idt-的软件中断服务程序对比)

**重要结论：BIOS 的 IVT 和 Kernel 的 IDT 都不仅设置硬件中断处理程序，还设置软件中断服务程序。**

### 3.1 BIOS IVT 设置的软件中断服务程序

| 中断向量 | 服务名称 | 功能说明 | 使用场景 |
|---------|---------|---------|---------|
| **INT 10h** | 视频服务 | 显示字符、设置显示模式、图形操作 | 引导程序显示启动信息 |
| **INT 13h** | 磁盘服务 | 读取/写入扇区、获取磁盘参数 | **引导程序加载内核** |
| **INT 15h** | 系统服务 | APM 电源管理、内存检测、系统配置 | 获取系统信息 |
| **INT 16h** | 键盘服务 | 读取按键输入、检查按键状态 | 交互式引导菜单 |
| **INT 19h** | 引导加载服务 | 加载并执行引导扇区 | **BIOS 启动引导过程** |
| **INT 1Ah** | 实时时钟服务 | 读取/设置系统时间 | 时间管理 |

**这些软件中断是 BIOS 提供给引导程序和早期系统软件的标准 API。**

### 3.2 软件中断与硬件中断的关系（以 INT 16h 为例）

虽然 INT 16h 是软件中断（由用户程序主动调用），但它确实需要处理键盘对应的硬件中断。它们的关系如下：

**键盘硬件中断（IRQ1，向量 0x09）：**
- 异步、由硬件触发，负责接收按键数据并存储到缓冲区

**软件中断 INT 16h（向量 0x16）：**
- 同步、由程序主动调用，负责从缓冲区读取数据并返回给程序

**协作关系：** 硬件中断"生产"数据，软件中断"消费"数据

### 3.3 Kernel IDT 设置的软件中断服务程序

| 中断向量 | 服务名称 | 功能说明 | 使用场景 |
|---------|---------|---------|---------|
| **INT 0x80**（32位） | 系统调用 | 用户空间调用内核服务 | 32位应用程序系统调用 |
| **SYSCALL**（64位） | 系统调用 | 用户空间调用内核服务 | 64位应用程序系统调用（使用 MSR，不通过 IDT） |
| **INT 0x80**（64位兼容） | 系统调用 | 兼容 32位应用程序 | 64位系统运行 32位程序 |

### 3.4 对比总结

| 特性 | BIOS IVT | Kernel IDT |
|------|----------|------------|
| **硬件中断处理** | ✅ 是（IRQ0-15） | ✅ 是（所有 IRQ） |
| **软件中断服务** | ✅ 是（INT 10h, 13h, 16h 等） | ✅ 是（INT 0x80 系统调用） |
| **服务对象** | 引导程序和早期系统软件 | 用户空间应用程序 |
| **调用方式** | `INT` 指令 | `INT 0x80` 或 `SYSCALL` 指令 |
| **运行模式** | 实模式（16位） | 保护模式/长模式（32/64位） |

**详细说明请参考：** [boot_flow.md - Section 6.5](boot_flow.md#65-bios-ivt-与-kernel-idt-的软件中断服务程序对比)

---

## 4. UEFI 中断处理机制

**详细内容请参考：** [boot_flow.md - Section 6.6](boot_flow.md#66-uefi-中断处理机制)

**重要说明：UEFI 与 BIOS 在中断处理机制上有根本性差异。**

### 4.1 UEFI 中断处理的特点

1. **不使用传统 IVT**：
   - UEFI **不使用**实模式下的中断向量表（IVT）
   - UEFI 固件本身在保护模式（32位）或长模式（64位）下运行
   - 使用 **IDT（中断描述符表）**，而不是 IVT

2. **事件驱动机制**：
   - UEFI 采用**事件驱动**的方式处理硬件和软件事件
   - 通过 **EFI_BOOT_SERVICES** 提供事件注册和处理机制
   - 不使用传统的 `INT` 指令调用服务，而是使用**函数调用**

3. **IDT 设置**：
   - UEFI 固件在启动时建立自己的 IDT
   - IDT 位置由 UEFI 固件指定（通过 IDTR 寄存器）
   - 主要用于处理 CPU 异常和硬件中断

4. **中断服务接口**：
   - **不提供软件中断服务**（如 BIOS 的 INT 10h, INT 13h）
   - 使用 **EFI 服务**（函数调用接口）替代传统中断服务
   - 通过 `EFI_SYSTEM_TABLE` 访问各种服务

### 4.2 UEFI vs BIOS 中断处理对比

| 特性 | BIOS（SeaBIOS） | UEFI |
|------|----------------|------|
| **中断表类型** | IVT（中断向量表，实模式） | IDT（中断描述符表，保护模式/长模式） |
| **中断表位置** | 固定地址 `0x0000:0000` | 由 IDTR 寄存器指定（不固定） |
| **运行模式** | 实模式（16位） | 保护模式（32位）或长模式（64位） |
| **软件中断服务** | ✅ 提供（INT 10h, 13h, 15h 等） | ❌ 不提供（使用 EFI 服务） |
| **服务调用方式** | `INT` 指令（软件中断） | 函数调用（通过 EFI_SYSTEM_TABLE） |
| **硬件中断处理** | 通过 PIC + IVT | 通过 APIC + IDT |
| **事件处理机制** | 中断驱动 | 事件驱动（CreateEvent, RegisterProtocolNotify） |

**详细说明请参考：** [boot_flow.md - Section 6.6](boot_flow.md#66-uefi-中断处理机制)

---

## 5. PIC 端口地址与地址解码

**详细内容请参考：** [APPENDIX_A_KEYBOARD_INTERRUPT.md](APPENDIX_A_KEYBOARD_INTERRUPT.md)

### 5.1 PIC 端口地址（硬件固定）

```c
// seabios/src/hw/pic.h:12-15
#define PORT_PIC1_CMD          0x0020  // 主 PIC 命令端口
#define PORT_PIC1_DATA         0x0021  // 主 PIC 数据端口
#define PORT_PIC2_CMD          0x00a0  // 从 PIC 命令端口
#define PORT_PIC2_DATA         0x00a1  // 从 PIC 数据端口
```

**这些端口地址是硬件固定的，不是 CPU 决定的！**

- **0x20/0x21**：主 PIC（8259A）的命令端口和数据端口
- **0xA0/0xA1**：从 PIC（8259A）的命令端口和数据端口
- 这些地址由 **IBM PC/AT 架构标准**决定，是 8259A PIC 芯片的硬件设计
- 所有兼容 IBM PC/AT 的系统都必须使用这些端口地址

### 5.2 CPU 如何找到这些端口地址？

**x86 CPU 的 I/O 端口寻址机制：**

x86 CPU 使用**独立的 I/O 地址空间**（与内存地址空间分离），通过专门的 I/O 指令访问：

```c
// 输出字节到 I/O 端口
static inline void outb(u8 value, u16 port) {
    __asm__ __volatile__("outb %b0, %w1" : : "a"(value), "Nd"(port));
}

// 从 I/O 端口读取字节
static inline u8 inb(u16 port) {
    u8 value;
    __asm__ __volatile__("inb %w1, %b0" : "=a"(value) : "Nd"(port));
    return value;
}
```

**CPU 访问 I/O 端口的完整流程：**

```
1. CPU 执行 outb(0x08, 0x21) 或 inb(0x21)
   ↓
2. CPU 将端口地址 0x21 放在地址总线上（I/O 地址空间）
   ↓
3. CPU 发出 I/O 读写信号（IOR#/IOW# 引脚）
   ↓
4. 主板上的地址解码电路（Address Decoder）检测到：
   - 地址总线 = 0x21
   - I/O 信号有效
   ↓
5. 地址解码电路将信号路由到对应的硬件设备（PIC 芯片）
   ↓
6. PIC 芯片接收数据/发送数据
```

**关键点：**
- **I/O 地址空间独立于内存地址空间**：
  - 内存地址：0x00000000 - 0xFFFFFFFF（32位系统）
  - I/O 地址：0x0000 - 0xFFFF（16位，64K 端口）
  - CPU 使用不同的指令访问：
    - 内存：`mov [0x1000], al`（访问内存地址 0x1000）
    - I/O：`outb %al, $0x21`（访问 I/O 端口 0x21）

- **地址解码电路（Address Decoder）**：
  - 位于主板上（或芯片组中）
  - 监听地址总线和 I/O 控制信号
  - 根据地址范围将信号路由到对应设备：
    ```
    0x20-0x3F → 主 PIC（8259A）
    0xA0-0xBF → 从 PIC（8259A）
    0x60-0x6F → 键盘控制器（8042）
    0x70-0x7F → CMOS/RTC
    ...
    ```

**详细说明请参考：** [APPENDIX_A_KEYBOARD_INTERRUPT.md](APPENDIX_A_KEYBOARD_INTERRUPT.md)

---

## 总结

本文档合并了所有中断相关的内容，包括：

1. **BIOS IVT 初始化**：如何为所有 256 个中断向量设置处理程序
2. **硬件中断 vs 软件中断**：IRQ 编号与中断向量号的区别和映射关系
3. **BIOS 与 Kernel 的对比**：两者都提供软件中断服务，但服务对象和调用方式不同
4. **UEFI 中断处理**：与 BIOS 的根本性差异，使用 IDT 和事件驱动机制
5. **PIC 端口地址**：硬件固定的 I/O 端口地址和地址解码机制

**更多详细信息请参考：**
- [boot_flow.md](boot_flow.md) - 完整的启动流程文档
- [APPENDIX_A_KEYBOARD_INTERRUPT.md](APPENDIX_A_KEYBOARD_INTERRUPT.md) - 键盘中断处理代码分析
- [APPENDIX_B_EVENT_MECHANISM.md](APPENDIX_B_EVENT_MECHANISM.md) - 应用层事件机制与操作系统实现

