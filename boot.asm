; boot.asm - 最小引导扇区程序
; 这是一个 512 字节的引导扇区程序，BIOS 会将其加载到内存地址 0x7C00 处执行

org 0x7C00
; org 指令：设置程序的起始地址为 0x7C00
; BIOS 会将引导扇区加载到内存地址 0x7C00 处，所以程序需要知道这个地址
; 这样后续的标签和变量地址才能正确计算

bits 16
; bits 指令：指定汇编器生成 16 位代码
; 引导扇区程序运行在实模式下，使用 16 位寄存器

start:
; start 标签：程序的入口点
; BIOS 会从引导扇区的第一个字节开始执行，所以这里就是程序的开始

    mov ax, 0x0003      ; 设置80x25文本模式
; mov 指令：将立即数 0x0003 移动到寄存器 ax
; ax 是累加寄存器（16位），0x0003 表示设置显示模式为 80x25 文本模式
; 这是 BIOS 视频服务（INT 0x10）的功能号

    int 0x10
; int 指令：调用 BIOS 中断 0x10（视频服务中断）
; 配合 ax=0x0003，这个中断调用会设置显示模式为 80 列 x 25 行的文本模式
; 清空屏幕并准备显示文本
    
    mov si, msg
; mov 指令：将 msg 标签的地址移动到寄存器 si
; si 是源索引寄存器（Source Index），用于字符串操作
; msg 是后面定义的消息字符串的地址

    mov ah, 0x0E
; mov 指令：将 0x0E 移动到寄存器 ah（ax 的高 8 位）
; ah=0x0E 是 BIOS 视频服务的功能号，表示"在 TTY 模式下显示字符"
; 这个功能会在当前光标位置显示字符，并自动移动光标

.print:
; .print 标签：打印循环的开始
; 点号（.）表示这是一个局部标签，属于 start 标签的作用域

    lodsb
; lodsb 指令：Load String Byte，从字符串加载一个字节
; 从 si 寄存器指向的内存地址读取一个字节到 al 寄存器，然后 si 自动加 1
; al 是 ax 的低 8 位，用于存储单个字符

    test al, al
; test 指令：测试 al 寄存器的值
; test al, al 会检查 al 是否为零（通过 al AND al 操作）
; 如果 al 为零，零标志位（ZF）会被设置

    jz .halt
; jz 指令：Jump if Zero，如果零标志位被设置则跳转
; 如果 al 为零（字符串结束符），跳转到 .halt 标签
; 否则继续执行下一条指令

    int 0x10
; int 指令：再次调用 BIOS 中断 0x10
; 此时 ah=0x0E（之前设置的），al 包含要显示的字符
; 这个中断调用会在屏幕上显示 al 中的字符

    jmp .print
; jmp 指令：无条件跳转到 .print 标签
; 继续循环，读取并显示下一个字符

.halt:
; .halt 标签：程序结束，进入无限循环
; 当字符串打印完成后，程序跳转到这里

    jmp $
; jmp 指令：跳转到当前地址（$ 表示当前地址）
; 这是一个无限循环，程序会一直在这里执行
; 引导扇区程序执行完后应该进入无限循环，等待用户操作或加载操作系统

msg db "Hello from Boot Sector!", 0
; db 指令：Define Byte，定义字节数据
; msg 是标签，指向这个字符串的起始地址
; "Hello from Boot Sector!" 是要显示的字符串
; 0 是字符串结束符（null terminator），用于标识字符串的结束

times 510-($-$$) db 0
; times 指令：重复指定次数的操作
; 
; 为什么是 510 字节？
; - 引导扇区的总大小必须是 512 字节（一个扇区的大小）
; - 最后 2 字节（第 511-512 字节）必须存储引导扇区标志 0xAA55
; - 因此，程序代码和数据部分最多只能占用前 510 字节（第 1-510 字节）
;
; 计算过程：
; - $ 表示当前地址（msg 字符串定义后的地址）
; - $$ 表示程序起始地址（org 0x7C00，即 0x7C00）
; - ($-$$) 计算从程序开始到当前位置已经使用的字节数
; - 510-($-$$) 计算还需要填充多少个 0 字节，才能让程序部分正好是 510 字节
;
; 示例：如果程序已经用了 50 字节，那么 510-50=460，需要填充 460 个 0
; 这样：50 字节程序 + 460 字节填充 = 510 字节，再加上 2 字节标志 = 512 字节

dw 0xAA55          ; 引导扇区标志
; dw 指令：Define Word，定义一个字（2 字节）的数据
; 0xAA55 是引导扇区的魔数（magic number）
; BIOS 会检查引导扇区的最后两个字节是否为 0xAA55
; 如果不是这个值，BIOS 会认为这不是有效的引导扇区，不会执行
; 注意：x86 是小端序，所以 0x55 在低地址，0xAA 在高地址

