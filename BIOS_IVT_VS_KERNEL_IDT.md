# BIOS IVT 与 Kernel IDT 的软件中断服务程序对比

本文档详细对比了 BIOS 的 IVT（中断向量表）和 Linux 内核的 IDT（中断描述符表）在软件中断服务程序方面的异同，帮助理解中断机制的设计模式。

---

**重要结论：BIOS 的 IVT 和 Kernel 的 IDT 都不仅设置硬件中断处理程序，还设置软件中断服务程序。**

**BIOS IVT 设置的软件中断服务程序：**

| 中断向量 | 服务名称 | 功能说明 | 使用场景 |
|---------|---------|---------|---------|
| **INT 10h** | 视频服务 | 显示字符、设置显示模式、图形操作 | 引导程序显示启动信息 |
| **INT 13h** | 磁盘服务 | 读取/写入扇区、获取磁盘参数 | **引导程序加载内核** |
| **INT 15h** | 系统服务 | APM 电源管理、内存检测、系统配置 | 获取系统信息 |
| **INT 16h** | 键盘服务 | 读取按键输入、检查按键状态 | 交互式引导菜单 |
| **INT 19h** | 引导加载服务 | 加载并执行引导扇区 | **BIOS 启动引导过程** |
| **INT 1Ah** | 实时时钟服务 | 读取/设置系统时间 | 时间管理 |

**这些软件中断是 BIOS 提供给引导程序和早期系统软件的标准 API。**

**重要说明：软件中断与硬件中断的关系（以 INT 16h 为例）**

虽然 INT 16h 是软件中断（由用户程序主动调用），但它确实需要处理键盘对应的硬件中断。它们的关系如下：

**键盘硬件中断（IRQ1，向量 0x09）：**

1. **硬件中断产生**：
   - 用户按下键盘 → 键盘控制器产生 IRQ1 硬件中断
   - PIC 将 IRQ1 映射到向量 0x09（BIOS_HWIRQ0_VECTOR + 1 = 0x08 + 1）

2. **硬件中断处理**：
   - CPU 查找 IVT 条目 0x09 → 跳转到 `entry_hwpic1`（主 PIC 硬件中断处理程序）
   - `entry_hwpic1` 调用 `handle_09()`（键盘硬件中断处理程序）

3. **数据接收和存储**：
   ```c
   // seabios/src/hw/ps2port.c:389-417
   void handle_09(void)  // 键盘硬件中断处理程序（向量 0x09）
   {
       // 从键盘控制器读取扫描码
       u8 v = inb(PORT_PS2_DATA);
       
       // 处理按键数据
       process_key(v);  // 调用 process_key() 处理扫描码
       
       // 发送 EOI（End of Interrupt）给 PIC
       pic_eoi1();
   }
   ```

4. **数据存储到缓冲区**：
   - `process_key()` 将扫描码转换为 ASCII 码
   - 将 ASCII 码存储到键盘缓冲区（BDA 中的键盘缓冲区）

**软件中断 INT 16h（向量 0x16）：**

1. **用户程序调用**：
   ```asm
   mov ah, 0x00        ; 功能号：读取按键
   int 0x16            ; 调用键盘服务
   ; 返回：AL = ASCII 码，AH = 扫描码
   ```

2. **软件中断处理**：
   - CPU 查找 IVT 条目 0x16 → 跳转到 `entry_16()`（键盘软件中断处理程序）
   - `entry_16()` 调用 `handle_16()`（C 语言处理程序）

3. **从缓冲区读取数据**：
   ```c
   // seabios/src/hw/ps2port.c:424-450
   void handle_16(void)  // 键盘软件中断处理程序（向量 0x16）
   {
       // 从键盘缓冲区读取数据
       u8 data = keyboard_getchar();
       
       // 返回给调用者（通过寄存器）
       // AL = ASCII 码，AH = 扫描码
   }
   ```

**关系总结：**

- **硬件中断（INT 09h）**：异步、由硬件触发，负责接收按键数据并存储到缓冲区
- **软件中断（INT 16h）**：同步、由程序主动调用，负责从缓冲区读取数据并返回给程序
- **协作关系**：硬件中断"生产"数据，软件中断"消费"数据

**Kernel IDT 设置的软件中断服务程序：**

| 中断向量 | 服务名称 | 功能说明 | 使用场景 |
|---------|---------|---------|---------|
| **INT 0x80**（32位） | 系统调用 | 用户空间调用内核服务 | 32位应用程序系统调用 |
| **SYSCALL**（64位） | 系统调用 | 用户空间调用内核服务 | 64位应用程序系统调用（使用 MSR，不通过 IDT） |
| **INT 0x80**（64位兼容） | 系统调用 | 兼容 32位应用程序 | 64位系统运行 32位程序 |

**对比总结：**

| 特性 | BIOS IVT | Kernel IDT |
|------|----------|------------|
| **硬件中断处理** | ✅ 是（IRQ0-15） | ✅ 是（所有 IRQ） |
| **软件中断服务** | ✅ 是（INT 10h, 13h, 16h 等） | ✅ 是（INT 0x80 系统调用） |
| **服务对象** | 引导程序和早期系统软件 | 用户空间应用程序 |
| **调用方式** | `INT` 指令 | `INT 0x80` 或 `SYSCALL` 指令 |
| **运行模式** | 实模式（16位） | 保护模式/长模式（32/64位） |

**关键源代码位置：**

- **BIOS 软件中断设置**：`seabios/src/post.c:568-582`（ivt_init 函数）
- **内核系统调用设置**：
  - 32位 INT 0x80：`linux/arch/x86/entry/entry_32.S`
  - 64位 syscall：`linux/arch/x86/entry/entry_64.S`（使用 MSR，不通过 IDT）

### UEFI 中断处理机制

**重要说明：UEFI 与 BIOS 在中断处理机制上有根本性差异。**

**UEFI 中断处理的特点：**

1. **不使用传统 IVT**：
   - UEFI **不使用**实模式下的中断向量表（IVT）
   - UEFI 固件本身在保护模式（32位）或长模式（64位）下运行
   - 使用 **IDT（中断描述符表）**，而不是 IVT

2. **事件驱动机制**：
   - UEFI 采用**事件驱动**的方式处理硬件和软件事件
   - 通过 **EFI_BOOT_SERVICES** 提供事件注册和处理机制
   - 不使用传统的 `INT` 指令调用服务，而是使用**函数调用**

3. **IDT 设置**：
   - UEFI 固件在启动时建立自己的 IDT
   - IDT 位置由 UEFI 固件指定（通过 IDTR 寄存器）
   - 主要用于处理 CPU 异常和硬件中断

4. **中断服务接口**：
   - **不提供软件中断服务**（如 BIOS 的 INT 10h, INT 13h）
   - 使用 **EFI 服务**（函数调用接口）替代传统中断服务
   - 通过 `EFI_SYSTEM_TABLE` 访问各种服务

**UEFI 中断处理流程：**

```
1. UEFI 固件启动（保护模式/长模式）
   ├─ 建立 IDT（中断描述符表）
   ├─ 设置 CPU 异常处理程序
   ├─ 设置硬件中断处理程序（通过 APIC）
   └─ 初始化 EFI_BOOT_SERVICES
    ↓
2. UEFI 驱动程序/应用程序注册事件处理程序
   ├─ 使用 CreateEvent() 创建事件
   ├─ 使用 RegisterProtocolNotify() 注册协议通知
   └─ 使用 SetTimer() 设置定时器事件
    ↓
3. 事件发生时，UEFI 调用注册的处理程序
   ├─ 硬件中断 → APIC → IDT → 中断处理程序 → 事件处理程序
   ├─ 定时器事件 → 定时器中断 → 事件处理程序
   └─ 协议事件 → 协议通知 → 事件处理程序
    ↓
4. 操作系统加载后，调用 ExitBootServices()
   ├─ 退出 UEFI Boot Services
   ├─ 释放 UEFI 控制的内存
   └─ 操作系统接管中断处理
```

**UEFI vs BIOS 中断处理对比：**

| 特性 | BIOS（SeaBIOS） | UEFI |
|------|----------------|------|
| **中断表类型** | IVT（中断向量表，实模式） | IDT（中断描述符表，保护模式/长模式） |
| **中断表位置** | 固定地址 `0x0000:0000` | 由 IDTR 寄存器指定（不固定） |
| **运行模式** | 实模式（16位） | 保护模式（32位）或长模式（64位） |
| **软件中断服务** | ✅ 提供（INT 10h, 13h, 15h 等） | ❌ 不提供（使用 EFI 服务） |
| **服务调用方式** | `INT` 指令（软件中断） | 函数调用（通过 EFI_SYSTEM_TABLE） |
| **硬件中断处理** | 通过 PIC + IVT | 通过 APIC + IDT |
| **事件处理机制** | 中断驱动 | 事件驱动（CreateEvent, RegisterProtocolNotify） |
| **中断处理程序设置** | `ivt_init()` 设置 IVT 条目 | UEFI 固件内部设置 IDT |

**UEFI 中断处理的关键接口：**

```c
// UEFI Boot Services 提供的事件处理接口
EFI_BOOT_SERVICES {
    // 创建事件
    EFI_CREATE_EVENT (
        IN UINT32 Type,              // 事件类型
        IN EFI_TPL NotifyTpl,        // 通知优先级
        IN EFI_EVENT_NOTIFY NotifyFunction,  // 通知函数
        IN VOID *NotifyContext,      // 通知上下文
        OUT EFI_EVENT *Event         // 返回的事件句柄
    );
    
    // 注册协议通知
    EFI_REGISTER_PROTOCOL_NOTIFY (
        IN EFI_GUID *Protocol,       // 协议 GUID
        IN EFI_EVENT_NOTIFY Event,   // 事件通知函数
        OUT VOID **Registration      // 注册句柄
    );
    
    // 设置定时器
    EFI_SET_TIMER (
        IN EFI_EVENT Event,          // 事件句柄
        IN EFI_TIMER_DELAY Type,     // 定时器类型
        IN UINT64 TriggerTime       // 触发时间
    );
}
```

**UEFI 中断处理示例：**

```c
// UEFI 驱动程序注册硬件中断处理程序
EFI_STATUS
MyDriverInterruptHandler (
    IN EFI_EXCEPTION_TYPE InterruptType,
    IN EFI_SYSTEM_CONTEXT SystemContext
)
{
    // 处理硬件中断
    // ...
    return EFI_SUCCESS;
}

// 注册中断处理程序（通过 UEFI 固件）
// UEFI 固件内部会设置 IDT 条目，指向这个处理程序
```

**关键点总结：**

1. **UEFI 不使用 IVT**：UEFI 在保护模式/长模式下运行，使用 IDT 而不是 IVT
2. **事件驱动**：UEFI 使用事件驱动机制，而不是传统的中断驱动
3. **函数调用**：UEFI 使用函数调用（EFI 服务）而不是 `INT` 指令
4. **固件管理**：UEFI 固件内部管理 IDT 的设置，应用程序通过 EFI 服务访问
5. **操作系统接管**：操作系统加载后调用 `ExitBootServices()` 退出 UEFI 环境，接管中断处理

**与 BIOS 的根本差异：**

- **BIOS**：实模式 → IVT → `INT` 指令 → 中断服务程序
- **UEFI**：保护模式/长模式 → IDT → 事件驱动 → EFI 服务（函数调用）

UEFI 的设计更加现代化，提供了更好的抽象和模块化，但不再提供传统的软件中断服务（如 INT 10h, INT 13h）。

### 接管完成标志

从内核加载 IDT 并重新编程 PIC 的那一刻起：
1. **硬件中断不再路由到 BIOS**：PIC 被重新编程，中断向量映射到内核的 IDT
2. **软件中断被内核接管**：所有 `INT` 指令触发的异常由内核的 IDT 处理
3. **BIOS 代码不再执行**：除了可能的 UEFI Runtime Services，BIOS 固件代码基本不再被调用
   ```

4. **数据放入缓冲区**：
   ```c
   // seabios/src/kbd.c:582-599
   void process_key(u8 key)
   {
       // 处理扫描码，转换为按键码
       __process_key(key);
   }
   
   // seabios/src/kbd.c:456-579
   void __process_key(u8 scancode)
   {
       // 将扫描码转换为按键码（考虑 Shift、Ctrl、Alt 等修饰键）
       u16 keycode = ...;  // 转换逻辑
       
       // 将按键码放入键盘缓冲区（BDA - BIOS Data Area）
       if (keycode)
           enqueue_key(keycode);  // 存储到缓冲区
   }
   ```

**INT 16h 软件中断服务：**

1. **用户程序调用**：
   ```asm
   mov ah, 0x00  ; INT 16h/AH=00h: 读取按键
   int 0x16      ; 调用 INT 16h 软件中断
   ; 返回：AX = 按键码
   ```

2. **软件中断处理**：
   ```c
   // seabios/src/kbd.c:244-270
   void handle_16(struct bregs *regs)  // INT 16h 软件中断处理程序
   {
       switch (regs->ah) {
       case 0x00: handle_1600(regs); break;  // 读取按键
       case 0x01: handle_1601(regs); break;  // 检查按键状态
       // ...
       }
   }
   ```

3. **从缓冲区读取数据**：
   ```c
   // seabios/src/kbd.c:117-120
   void handle_1600(struct bregs *regs)  // INT 16h/AH=00h: 读取按键
   {
       dequeue_key(regs, 1, 0);  // 从缓冲区读取按键码
       // 返回：AX = 按键码
   }
   ```

**完整流程：**

```
1. 用户按下键盘
   ↓
2. 键盘硬件产生 IRQ1 中断
   ↓
3. PIC 路由到向量 0x09
   ↓
4. CPU 查找 IVT[0x09] → entry_hwpic1 → handle_09()
   ↓
5. handle_09() 读取扫描码 → process_key() → __process_key() → enqueue_key()
   ↓
6. 按键数据存储到键盘缓冲区（BDA）
   ↓
7. 用户程序调用 INT 16h
   ↓
8. CPU 查找 IVT[0x16] → entry_16 → handle_16() → handle_1600() → dequeue_key()
   ↓
9. 从缓冲区读取按键数据，返回给用户程序
```

**关键点总结：**

1. **硬件中断（IRQ1，向量 0x09）**：
   - **触发方式**：硬件自动触发（用户按下键盘）
   - **处理程序**：`handle_09()`（硬件中断处理程序）
   - **功能**：接收键盘数据并存储到缓冲区
   - **时机**：异步（按键时立即触发）

2. **软件中断（INT 16h，向量 0x16）**：
   - **触发方式**：用户程序主动调用（`INT 0x16` 指令）
   - **处理程序**：`handle_16()`（软件中断服务程序）
   - **功能**：从缓冲区读取数据并返回给用户程序
   - **时机**：同步（用户程序需要时调用）

3. **它们的关系**：
   - **硬件中断负责"输入"**：接收键盘数据并存储
   - **软件中断负责"输出"**：从缓冲区读取数据并返回
   - **缓冲区是桥梁**：硬件中断写入，软件中断读取

**类似的设计模式：**

其他 BIOS 软件中断服务也有类似的设计：
- **INT 13h（磁盘服务）**：硬件中断（IRQ14/IRQ15，IDE 控制器）处理磁盘 I/O 完成，软件中断提供读取/写入扇区的 API
- **INT 10h（视频服务）**：硬件中断（IRQ0，定时器）可能用于屏幕刷新，软件中断提供显示字符/图形的 API

**重要澄清：硬件中断与软件中断的独立性**

**如果用户程序不主动调用 INT 16h，系统仍然会处理按键！**

关键点：
1. **硬件中断是自动的**：
   - 用户按下键盘 → IRQ1 硬件中断自动触发
   - `handle_09()` 硬件中断处理程序**会自动执行**，无论用户程序是否调用 INT 16h
   - 按键数据**会自动存储到缓冲区**（通过 `enqueue_key()`）

2. **软件中断是可选的**：
   - INT 16h 只是从缓冲区**读取**数据的接口
   - 如果用户程序不调用 INT 16h，数据会**留在缓冲区中**，但硬件中断已经处理了按键

3. **缓冲区机制**：
   ```c
   // seabios/src/kbd.c:32-52
   u8 enqueue_key(u16 keycode)
   {
       // 检查缓冲区是否已满
       if (buffer_tail == buffer_head)
           return 0;  // 缓冲区满，返回失败
       
       // 将按键码存入缓冲区
       SET_FARVAR(SEG_BDA, *(u16*)(temp_tail+0), keycode);
       SET_BDA(kbd_buf_tail, buffer_tail);
       return 1;  // 成功
   }
   ```
   - 缓冲区有固定大小（通常 16-32 个按键）
   - 如果缓冲区满了，新的按键数据会丢失（`enqueue_key()` 返回 0）

4. **两种场景对比**：

   **场景 A：用户程序调用 INT 16h**
   ```
   按键 → 硬件中断 → 数据存入缓冲区 → 用户程序调用 INT 16h → 从缓冲区读取数据
   ```
   - 数据被及时读取和使用
   - 缓冲区有空间接收新按键

   **场景 B：用户程序不调用 INT 16h**
   ```
   按键 → 硬件中断 → 数据存入缓冲区 → [数据留在缓冲区中]
   ```
   - 硬件中断仍然处理了按键（数据已存入缓冲区）
   - 但数据没有被读取，会一直留在缓冲区中
   - 如果缓冲区满了，后续按键会丢失

5. **实际影响**：
   - **硬件中断处理是必须的**：即使不调用 INT 16h，硬件中断也会执行，数据会存入缓冲区
   - **软件中断只是访问接口**：INT 16h 只是读取缓冲区数据的 API
   - **数据丢失风险**：如果长时间不调用 INT 16h，缓冲区满了之后，新按键会丢失

**总结：**

- **硬件中断（IRQ1）是自动的**：无论是否调用 INT 16h，硬件中断都会处理按键并存储到缓冲区
- **软件中断（INT 16h）是可选的**：只是从缓冲区读取数据的接口
- **如果用户程序不调用 INT 16h**：
  - ✅ 硬件中断仍然会处理按键（数据存入缓冲区）
  - ❌ 但数据不会被读取和使用（留在缓冲区中）
  - ⚠️ 缓冲区满了之后，新按键会丢失

**类比：**
- 硬件中断 = 邮递员将信件放入邮箱（自动发生）
- 软件中断 = 你打开邮箱取信（需要主动操作）
- 即使你不取信，邮递员仍然会投递信件，但邮箱满了之后，新信件可能无法投递

**Kernel IDT 设置的软件中断服务程序：**

| 中断向量/机制 | 服务名称 | 功能说明 | 使用场景 |
|-------------|---------|---------|---------|
| **INT 0x80**（32位） | 系统调用 | 用户空间程序调用内核服务 | 传统 32 位系统调用 |
| **syscall 指令**（64位） | 系统调用 | 用户空间程序调用内核服务 | 现代 64 位系统调用（不通过 IDT） |
| **sysenter 指令**（32位） | 系统调用 | 用户空间程序调用内核服务 | 快速系统调用（不通过 IDT） |

**系统调用是内核提供给用户空间程序的标准 API。**

**对比总结：**

| 特性 | BIOS IVT | Kernel IDT |
|------|----------|------------|
| **硬件中断** | ✅ 设置（IRQ0-15，向量 0x08-0x0F, 0x70-0x77） | ✅ 设置（IRQ0-15，向量 0x20-0x2F 或 APIC 向量） |
| **软件中断服务** | ✅ 设置（INT 10h, 13h, 15h, 16h, 19h 等） | ✅ 设置（INT 0x80 系统调用，或 syscall 指令） |
| **服务对象** | 引导程序和早期系统软件 | 用户空间程序 |
| **服务类型** | 硬件抽象层（HAL）服务 | 操作系统服务 |
| **调用方式** | `INT` 指令（软件中断） | `INT 0x80` 或 `syscall` 指令 |

**关键点：**

1. **BIOS IVT**：
   - 不仅处理硬件中断（IRQ），还提供软件中断服务（INT 10h, 13h 等）
   - 这些服务是 BIOS 提供给引导程序的标准 API
   - 最常用的是 **INT 13h（磁盘服务）**，引导程序用它来读取内核

2. **Kernel IDT**：
   - 不仅处理硬件中断（IRQ），还提供系统调用接口
   - 系统调用是内核提供给用户空间程序的标准 API
   - 传统方式：**INT 0x80**（通过 IDT）
   - 现代方式：**syscall/sysenter 指令**（不通过 IDT，使用 MSR）

3. **设计模式**：
   - 两者都采用"硬件中断 + 软件服务"的设计模式
   - BIOS 提供硬件抽象层服务（HAL）
   - 内核提供操作系统服务（OS）

**源代码位置：**

- **BIOS 软件中断设置**：`seabios/src/post.c:568-582`（ivt_init 函数）
- **内核系统调用设置**：
  - 32位 INT 0x80：`linux/arch/x86/entry/entry_32.S`
  - 64位 syscall：`linux/arch/x86/entry/entry_64.S`（使用 MSR，不通过 IDT）

