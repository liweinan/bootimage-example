# 键盘输入处理演示程序

这个示例演示了如何在引导扇区程序中处理键盘输入，通过硬件中断机制捕获按键事件。

## 文件说明

- `keyboard_demo.asm` - 键盘输入处理演示程序
- 实现了键盘中断挂钩、扫描码读取、ASCII 转换和消息显示

## 程序功能

程序演示了以下功能：

1. **键盘中断挂钩**
   - 保存原始 BIOS 键盘中断向量（INT 09h）
   - 设置自定义键盘中断处理程序
   - 保持与 BIOS 的兼容性

2. **按键检测**
   - 从键盘端口（0x60）读取扫描码
   - 区分按键按下和释放事件
   - 只处理按键按下事件

3. **扫描码转换**
   - 将键盘扫描码转换为 ASCII 码
   - 支持字母、数字和部分符号键

4. **消息显示**
   - 当用户按下按键时，显示：`'x' was pressed!`
   - 实时响应键盘输入

## 编译和运行

### 方法 1：使用 Makefile（推荐）

```bash
# 编译
make keyboard-demo

# 在图形窗口中运行
make keyboard-demo-gui

# 在终端中运行（适合 SSH 或无图形界面）
make keyboard-demo-term
```

### 方法 2：手动编译和运行

```bash
# 编译
nasm -f bin keyboard_demo.asm -o keyboard_demo.bin

# 在 QEMU 图形窗口中运行
qemu-system-x86_64 -display sdl -drive format=raw,file=keyboard_demo.bin

# 在终端中运行
qemu-system-x86_64 -display curses -drive format=raw,file=keyboard_demo.bin
```

## 使用方法

1. **启动程序**
   - 编译并运行程序后，会显示欢迎消息和提示

2. **按下按键**
   - 按下键盘上的任意按键（字母、数字等）
   - 程序会立即显示：`'x' was pressed!`（x 是按键字符）

3. **退出程序**
   - 在图形窗口模式：按 `Ctrl+Alt+G` 释放鼠标，然后关闭窗口
   - 在终端模式：按 `Ctrl+A`，松开后按 `X`（大写）

## 代码说明

### 键盘中断处理流程

```
用户按下按键
    ↓
键盘控制器发送中断信号（IRQ1）
    ↓
CPU 硬件中断（自动保存状态）
    ↓
跳转到 INT 09h 处理程序（我们的 keyboard_handler）
    ↓
从键盘端口读取扫描码
    ↓
将扫描码转换为 ASCII 码
    ↓
显示消息：'x' was pressed!
    ↓
发送 EOI 到 PIC
    ↓
调用原始 BIOS 处理程序
    ↓
返回（IRET）
```

### 核心函数

**setup_keyboard_handler**
- 保存原始 INT 09h 中断向量
- 设置新的中断向量指向我们的处理程序

**keyboard_handler**
- 从端口 0x60 读取扫描码
- 检查按键状态（按下/释放）
- 转换扫描码为 ASCII
- 显示消息
- 发送 EOI 并调用原始处理程序

**scancode_to_ascii**
- 使用查找表将扫描码转换为 ASCII 码
- 支持字母、数字和部分符号键

### 扫描码说明

键盘扫描码是键盘控制器发送的原始按键代码：

- **扫描码范围**：0x01-0x83
- **按键状态**：最高位（bit 7）表示状态
  - 0 = 按键按下（Make Code）
  - 1 = 按键释放（Break Code）
- **示例**：
  - 0x1E = 'a' 键按下
  - 0x9E = 'a' 键释放（0x1E | 0x80）

### 支持的按键

程序支持以下按键（可以通过扩展扫描码表添加更多）：

- **数字键**：0-9
- **字母键**：a-z（小写）
- **符号键**：空格、减号、等号、方括号、分号、单引号、反引号、反斜杠、逗号、句号、斜杠
- **控制键**：退格、回车、Tab

## 预期输出

运行程序后，你会看到：

```
=== Keyboard Input Demo ===
Press any key to see the message...

Keyboard handler installed. Waiting for input...

```

当你按下按键（例如按下 'a'）时，会显示：

```
'a' was pressed!
```

继续按其他按键，会继续显示相应的消息。

## 技术细节

### 键盘端口

- **0x60**：键盘数据端口（Keyboard Data Port）
  - 读取：获取扫描码
  - 写入：发送命令到键盘

- **0x64**：键盘控制端口（Keyboard Control Port）
  - 读取：获取键盘状态
  - 写入：发送控制命令

### 中断控制器（PIC）

- **0x20**：主 PIC 命令端口
  - 写入 0x20：发送 EOI（End of Interrupt）命令
  - 告诉 PIC 中断已被处理，可以处理下一个中断

### 中断向量表（IVT）

- **INT 09h**：键盘中断
  - 向量地址：0x09 × 4 = 0x0024
  - 存储：处理程序的段地址和偏移地址

## 扩展功能

你可以尝试添加以下功能：

1. **支持 Shift 键**
   - 检测 Shift 键状态
   - 显示大写字母

2. **支持功能键**
   - F1-F12 键
   - 方向键
   - 特殊键（Home, End, Page Up/Down 等）

3. **键盘缓冲区**
   - 存储多个按键
   - 支持按键队列

4. **按键组合**
   - Ctrl+C, Alt+F4 等
   - 快捷键处理

## 注意事项

1. **中断处理程序必须快速执行**
   - 长时间处理会阻塞其他中断
   - 可能导致系统响应变慢

2. **必须发送 EOI**
   - 不发送 EOI 会导致中断被屏蔽
   - 系统可能无法响应后续中断

3. **必须调用原始处理程序**
   - BIOS 需要更新键盘缓冲区
   - 保持系统兼容性

4. **扫描码表不完整**
   - 当前只支持部分按键
   - 可以扩展扫描码表支持更多按键

## 相关文档

- 查看 `GUIDE.md` 了解中断机制的完整说明
- 查看 `event_demo.asm` 了解事件机制
- 查看 `manual_int_demo.asm` 了解如何手动实现中断调用

## 故障排除

### 问题：按键没有响应

- **检查**：确保 QEMU 窗口有焦点
- **解决**：点击 QEMU 窗口，确保键盘输入被捕获

### 问题：显示乱码

- **原因**：扫描码转换表不完整
- **解决**：扩展扫描码表，添加更多按键支持

### 问题：程序崩溃

- **检查**：中断处理程序是否正确保存和恢复寄存器
- **检查**：是否正确发送 EOI
- **检查**：是否正确调用原始处理程序

